/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VECTOR2"] = factory();
	else
		root["VECTOR2"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@catsums/my/lib/umd/index.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/@catsums/my/lib/umd/index.min.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(()=>(()=>{\"use strict\";var e={144:(e,t,n)=>{e.exports=n(728)},728:(e,t,n)=>{var r=function(e,t){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var n=o(t);if(n&&n.has(e))return n.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(\"default\"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var u=i?Object.getOwnPropertyDescriptor(e,a):null;u&&(u.get||u.set)?Object.defineProperty(r,a,u):r[a]=e[a]}return r.default=e,n&&n.set(e,r),r}(n(390));function o(e){if(\"function\"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(o=function(e){return e?n:t})(e)}e.exports=r},390:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:!0}),t.JSONobjectsAreEqual=function(e,t){return JSON.stringify(e)===JSON.stringify(t)},t.ajax=s,t.ajaxGET=function(e,t,n=function(){}){s(\"\",e,\"GET\",t,n)},t.ajaxPOST=function(e,t,n,r=function(){}){s(e,t,\"POST\",n,r)},t.areSimilar=function e(t,n){if(t==n)return!0;if(h(t)&&h(n)){t=JSON.parse(JSON.stringify(t)),n=JSON.parse(JSON.stringify(n));for(let r of Object.keys(t)){if(!(r in n))return!1;if(!e(t[r],obj[r]))return!1}return!0}return typeof a==typeof b&&a===b},t.arrayRemove=function(e,t){var n=e.indexOf(t);return!(n<0)&&e.splice(n,1).length>0},t.checkBootstrapMedia=function(){Object.keys(o);for(var e=Object.values(o),t=e.length-1;t>=0;t--){var n=e[t];if(window.matchMedia(`(max-width: ${n})`).matches)return qKey}return\"xs\"},t.checkCookie=function(e){return\"\"!=f(e)},t.clog=function(...e){console.log(...e)},t.cout=function(...e){console.log(...e)},t.deepEqual=function e(t,n){let r=Object.keys(t),o=Object.keys(n);if(r.length!==o.length)return!1;for(let o of r){let r=t[o],i=n[o],a=h(r)&&h(i);if(a&&!e(r,i)||!a&&r!==i)return!1}return!0},t.defectAllFormSubmits=function(){var e=document.getElementsByTagName(\"form\");for(var t of e)t.submit=()=>{},t.addEventListener(\"submit\",i)},t.deg2rad=function(e){return e*Math.PI/180},t.deleteCookie=function(e){document.cookie=e+\"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\"},t.docReady=function(e){\"complete\"===document.readyState||\"interactive\"===document.readyState?setTimeout(e,1):document.addEventListener(\"DOMContentLoaded\",e)},t.findItem=function(e,t){return!1!==v(e,t)},t.findItemIndex=v,t.findItemObject=function(e,t,n=null){return!1!==x(e,t,n)},t.findItemObjectIndex=x,t.footstrapMediaQueries=void 0,t.forMediaQuery=function(e,t,n){window.matchMedia(e).matches?t():n()},t.formDataToJSON=function(e,t=!1){var n={};return e.forEach(((e,t)=>{Reflect.has(n,t)?(Array.isArray(n[t])||(n[t]=[n[t]]),n[t].push(e)):n[t]=e})),t?JSON.stringify(n):n},t.getAverageFrom=function(e){return l(e)?e.length?e.reduce(((e,t)=>e+t),0)/e.length:0:null},t.getBase64=async function(e){return new Promise(((t,n)=>{let r=new FileReader;r.onload=()=>t(r.result),r.onerror=e=>{n(e)},r.readAsDataURL(e)}))},t.getCSSValueInPixels=function(e){let t=0,n=parseFloat(e);switch(e.replace(`${n}`,\"\").trim()){case\"in\":t=96*n;break;case\"cm\":t=n/2.54*96;break;case\"mm\":t=n/100/2.54*96;break;case\"pt\":t=72*n*96;break;case\"pc\":t=12*n*72*96;break;default:t=n}return t},t.getClosestPathInCircle=function(e,t,r,o=0){if(!(e instanceof Array))return[];if(t<0||t>=e.length)return[];if(r<0||r>=e.length)return[];let i,a=iR=t,u=[],s=[];for(;u.length<e.length;){let t=n(a,e.length);if(u.push(e[t]),Math.abs(t)==r)break;a--}for(;s.length<e.length;){let t=n(iR,e.length);if(s.push(e[t]),Math.abs(t)==r)break;iR++}return i=Math.abs(u.length)<Math.abs(s.length)?u:Math.abs(u.length)>Math.abs(s.length)||o>0?s:u,i},t.getCookie=f,t.getFileBlob=function(e,t=\"\",n=((e,t,n)=>{})){var r=new XMLHttpRequest;r.open(\"GET\",e,!0),r.responseType=\"arraybuffer\",r.onload=function(e){var o=r.response,i=new Uint8Array(o),a=new Blob([o],{type:t}),u=URL.createObjectURL(a);n(u,a,i)},r.send()},t.getFormData=function(e){var t;if(\"string\"==typeof e)t=document.querySelector(e);else{if(!(e instanceof HTMLFormElement))return null;t=e}return new FormData(t)},t.getObjectFromArray=function(e,t){if(!(e&&e instanceof Array))return!1;if(!t)return!1;if(0==e.length)return!1;for(var n=t,r=Object.keys(n),o=0;o<e.length;o++){var i=e[o];if(i instanceof Object&&n instanceof Object){if(r&&r instanceof Array){for(let e of r)if(i.hasOwnProperty(e)&&i[e]===n[e])return i}else if(O(i,n))return i}else if(i===n)return i}return!1},t.hardPush=function(e,t,n){if(!(e&&e instanceof Array))return!1;if(!t)return!1;if(!e.length)return e.push(t),!0;if(e.indexOf(t)>=0)return!1;for(var r=0;r<e.length;r++){var o=e[r];if(h(o)&&h(t)){if(n&&l(n))for(let e of n)if(e in o&&compareVars(o[a],t[b]))return!1}else if(o===t)return!1}return e.push(t),!0},t.hash128=function(e){var t=S(e);return t+S(t+e)},t.hash32=y,t.hash64=S,t.hexadecimalID=function(e=16,t=4){return Math.floor((1+Math.random())*Math.pow(e,t)).toString(16).substring(1)},t.isArray=l,t.isExternalURL=function(e){var t=!1;try{t=new URL(e).origin!==location.origin}catch(e){return!1}return t},t.isExternalURLFast=function(e){var t=e.match(/^([^:\\/?#]+:)?(?:\\/\\/([^\\/?#]*))?([^?#]+)?(\\?[^#]*)?(#.*)?/);return\"string\"==typeof t[1]&&t[1].length>0&&t[1].toLowerCase()!==location.protocol||\"string\"==typeof t[2]&&t[2].length>0&&t[2].replace(new RegExp(\":(\"+{\"http:\":80,\"https:\":443}[location.protocol]+\")?$\"),\"\")!==location.host},t.isFunction=function(e){return\"function\"==typeof e||e instanceof Function},t.isInRange=function(e,t,n,r=!0){return r?e>=t&&e<=n:e>t&&e<n},t.isInfinity=r,t.isInt=function(e){return c(e)&&Math.trunc(e)===e},t.isJSON=g,t.isNumber=c,t.isObject=h,t.isString=p,t.jsonFix=function(e){return(e=String(e)).replace(/\\,(?!\\s*?[\\{\\[\\\"\\'\\w])/g,\"\")},t.link_is_external=function(e,t=window.location){return e.host!==t.host},t.loadHTMLtoObject=function(e,t){document.querySelector(e).setAttribute(\"data\",t)},t.logg=u,t.mod=n,t.myAjax=function(e,t,n=\"\",r=\"POST\",o=!0){var i=new XMLHttpRequest;i.onreadystatechange=function(){if(4==i.readyState)if(console.log(\"STATUS:\"+i.status),i.status>=200&&i.status<300)if(g(i.responseText)){var e=JSON.parse(i.responseText);t(e)}else t(i.responseText);else i.status>=300&&g(i.responseText)?h(e=JSON.parse(i.responseText))&&\"message\"in e&&(o?u(e.message):console.log(e.message)):o?u(i.responseText):console.log(i.responseText);else o&&u(\"Loading...\"+i.readyState)},i.open(r,n,!0),i.setRequestHeader(\"Content-Type\",\"application/json\"),i.setRequestHeader(\"Content-Type\",\"multipart/form-data\"),\"POST\"==r.toUpperCase()?i.send(JSON.stringify(e)):i.send()},t.mysql_real_escape_string=function(e){return e.replace(/[\\0\\x08\\x09\\x1a\\n\\r\"'\\\\\\%]/g,(function(e){switch(e){case\"\\0\":return\"\\\\0\";case\"\\b\":return\"\\\\b\";case\"\\t\":return\"\\\\t\";case\"\u001a\":return\"\\\\z\";case\"\\n\":return\"\\\\n\";case\"\\r\":return\"\\\\r\";case'\"':case\"'\":case\"\\\\\":case\"%\":return\"\\\\\"+e;default:return e}}))},t.objectToURLParams=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(encodeURIComponent(n)+\"=\"+encodeURIComponent(e[n]));return\"?\"+t.join(\"&\")},t.parseURLParams=function(e,t=!1,n=!1){var r,o,i,a,u,s=e.indexOf(\"?\")+1,f=e.indexOf(\"#\")+1||e.length+1,c=e.slice(s,f-1),l=c.replace(/\\+/g,\" \").split(\"&\"),p={};if(c!==e&&\"\"!==c){for(r=0;r<l.length;r++){if(a=l[r].split(\"=\",2),o=decodeURIComponent(a[0]),i=decodeURIComponent(a[1]),u=null,t){if(n&&o.includes(\"[\"))if(o.includes(\"[]\"))o=o.replace(\"[]\",\"\"),p.hasOwnProperty(o)||(p[o]=[]);else if(o.includes(\"]\")){var h=o.split(\"[\",2);o=h[0],u=h[1].replace(\"]\",\"\"),p.hasOwnProperty(o)||(p[o]={}),p[o][u]=null}i=isNaN(i)?\"undefined\"===(i=\"true\"===i||\"false\"!==i&&i)?void 0:\"null\"===i?null:i:Number(i)}p.hasOwnProperty(o)?\"object\"!=typeof p[o]?p[o]=[p[o]]:p[o]instanceof Array?p[o].push(2===a.length?i:null):null!=u&&(p[o][u]=i):p[o]=i}return p}},t.processAjaxData=function(e,t=\"\",n=null,r={},o=function(){}){var i=jQuery.extend(!0,{},r);n?(i.html=n.html,i.pageTitle=n.pageTitle,e&&(e.innerHTML=n.html),document.title=n.pageTitle):(i.html=\"\",i.pageTitle=\"\"),window.history.pushState(i,i.pageTitle,t),o()},t.pushHistoryState=function(e=\"\",t=null,n={},r=function(){}){var o=jQuery.extend(!0,{},n);t?(o.html=t.html,o.pageTitle=t.pageTitle,document.title=t.pageTitle):(o.html=\"\",o.pageTitle=\"\"),window.history.pushState(o,o.pageTitle,e),r()},t.rad2deg=function(e){return 180*e/Math.PI},t.randomCharFrom=function(e){return d(1,e)},t.randomID=function(e=\"\",t=\"\",n=9){return e+d(9)+t},t.randomId=function(e=\"\",t=\"\"){return e+Math.random().toString(36).substr(2,9)+t},t.randomItemFrom=function(e){return e[m(0,e.length-1)]},t.randomString=d,t.rndInt=m,t.safeDivide=function(e,t,n=!1){return 0==e&&0==t?res=n?NaN:0:0==e&&r(t)?res=0:r(e)&&0==t?res=e:r(e)&&r(t)?res=n?NaN:1:0==t?(n&&(res=NaN),res=1/0*e):r(t)?(n&&(res=NaN),res=0*e):res=e/t,res},t.safeStringify=function(e){let t=[],n=JSON.stringify(e,((e,n)=>{if(h(n)){if(t.includes(n))return;t.push(n)}return n}));return t=null,n},t.sanitizeString=function(e){return(e=e.replace(/[^a-z0-9áéíóúñü \\.,_-]/gim,\"\")).trim()},t.setCookie=function(e,t,n=1){let r=new Date;r.setTime(r.getTime()+24*n*60*60*1e3);let o=\"expires=\"+r.toUTCString();document.cookie=e+\"=\"+t+\";\"+o+\"; path=/\"},t.setHistoryState=function(e=\"\",t=null,n={},r=function(){}){var o=jQuery.extend(!0,{},n);t?(o.html=t.html,o.pageTitle=t.pageTitle,document.title=t.pageTitle):(o.html=\"\",o.pageTitle=\"\"),window.history.replaceState(o,o.pageTitle,e),r()},t.shallowEqual=O,t.splitStringByLength=function(e,t){for(var n=[],r=0;r<e.length;r+=t)n.push(e.substring(r,r+t));return n},t.stepify=function(e,t){return 0==t?e:t==1/0?1:Math.round((e+Number.EPSILON)/t)*t},t.stringTrimToLength=function(e,t){return null==t&&(t=String(e).length),(e=String(e)).substring(0,t)},t.submitForm=function(e,t,n){var r=document.querySelector(e);s(new FormData(r),t,n,r.getAttribute(\"method\"))},t.validateEmail=function(e){return String(e).toLowerCase().match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/)};try{\"undefined\"!=typeof Storage&&(Storage.prototype.setObject=function(e,t){this.setItem(e,JSON.stringify(t))},Storage.prototype.getObject=function(e){var t=this.getItem(e);return t&&JSON.parse(t)})}catch(e){console.debug(e)}function n(e,t){return(e%t+t)%t}function r(e){return e===-1/0||e===1/0}Array.prototype.midCeil=function(){return this[Math.ceil(this.length/2)]},Array.prototype.midFloor=function(){return this[Math.floor(this.length/2)]},Array.prototype.midRound=function(){return this[Math.round(this.length/2)]},Array.prototype.last=function(){return this[this.length-1]},Array.prototype.first=function(){return this[0]},Array.prototype.removeAt=function(e){return this.splice(e,1)},Array.prototype.removeItem=function(e){let t=this.indexOf(e);return this.splice(t,1)>0},BigInt.prototype.toJSON=function(){return this.toString()},Number.prototype.mod=function(e){return(this%e+e)%e};let o={xs:\"0px\",sm:\"576px\",md:\"768px\",lg:\"992px\",xl:\"1200px\",xxl:\"1400px\"};t.footstrapMediaQueries=o;var i=e=>{e.preventDefault(),console.debug(\"Submit has been defected. Please use JS to override form submit\")};function u(e){var t=\"\";if(document.querySelectorAll(\".logg\")?t=\".logg\":document.querySelectorAll(\".mess\")&&(t=\".mess\"),\"\"!=t)for(var n=document.querySelectorAll(t),r=0;r<n.length;r++)n[r].innerHTML=e;else console.log(e)}function s(e,t=\"\",n=\"POST\",r=function(){},o=function(){}){var i=new XMLHttpRequest;i.onreadystatechange=function(){4==i.readyState&&(console.log(\"STATUS:\"+i.status),i.status>=200&&i.status<300?r(i.responseText):i.status>=300?o(i.responseText):console.log(i.responseText))},i.open(n,t,!0),\"POST\"==n.toUpperCase()?i.send(e):i.send()}function f(e){for(var t=e+\"=\",n=decodeURIComponent(document.cookie).split(\";\"),r=0;r<n.length;r++){for(var o=n[r];\" \"==o.charAt(0);)o=o.substring(1);if(0==o.indexOf(t))return o.substring(t.length,o.length)}return\"\"}function c(e){return!isNaN(Number(e))}function l(e){return\"object\"==typeof e&&e instanceof Array}function p(e){return\"string\"==typeof e}function h(e){return null!=e&&\"object\"==typeof e}function g(e){p(e)||(e=JSON.stringify(e));let t=null;try{t=JSON.parse(e)}catch(e){return!1}return!!h(t)}function d(e,t){t=t?String(t):\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";for(var n=\"\",r=e;r>0;--r)n+=t[Math.floor(Math.random()*t.length)];return n}function m(e,t){return Math.floor(Math.random()*(t-e+1))+e}function y(e){var t,n=0;if(0===(e=String(e)).length)return n;for(t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return String(n)}function S(e){var t=y(e);return t+y(t+e)}function O(e,t){let n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(let r of n)if(e[r]!==t[r])return!1;return!0}function v(e,t){if(!(e&&e instanceof Array))return null;if(!t)return null;for(let n=0;n<e.length;n++){let r=e[n];if(h(r)&&h(t)){if(O(r,t))return n;if(r===t)return n}}return!1}function x(e,t,n=null){if(!(e&&e instanceof Array))return!1;if(!t)return!1;if(0==e.length)return!1;for(var r=0;r<e.length;r++){var o=e[r];if(o instanceof Object&&t instanceof Object){if(n&&n instanceof Array){for(var i of n)if(o.hasOwnProperty(i)&&o[i]===t[i])return r}else if(O(o,t))return r}else if(o===t)return r}return!1}}},t={};return function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}(144)})()));\n\n//# sourceURL=webpack://VECTOR2/./node_modules/@catsums/my/lib/umd/index.min.js?");

/***/ }),

/***/ "./lib/cjs/index.js":
/*!**************************!*\
  !*** ./lib/cjs/index.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./src */ \"./lib/cjs/src/index.js\");\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/index.js?");

/***/ }),

/***/ "./lib/cjs/src/Rect2/Rect2.js":
/*!************************************!*\
  !*** ./lib/cjs/src/Rect2/Rect2.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Rect2 = void 0;\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.min.js\"));\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \"./lib/cjs/src/Vector2/Vector2.js\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass Rect2 {\n  position;\n  size;\n  static getFromPoints(points) {\n    let xMin, xMax, yMin, yMax;\n    xMax = yMax = -Infinity;\n    xMin = yMin = Infinity;\n    for (let pt of points) {\n      if (xMin == null || xMin > pt.x) xMin = pt.x;\n      if (yMin == null || yMin > pt.y) yMin = pt.y;\n      if (xMax == null || xMax < pt.x) xMax = pt.x;\n      if (yMax == null || yMax < pt.y) yMax = pt.y;\n    }\n    let w = xMax - xMin;\n    let h = yMax - yMin;\n    return new Rect2(xMin, yMin, w, h);\n  }\n  get start() {\n    return new _Vector.Vector2(this.left, this.top);\n  }\n  get end() {\n    return new _Vector.Vector2(this.right, this.bottom);\n  }\n  get center() {\n    return _Vector.Vector2.MIDPOINT([this.start, this.end]);\n  }\n  get extents() {\n    return _Vector.Vector2.SUBTRACT(this.center, this.start);\n  }\n  get topLeft() {\n    return new _Vector.Vector2(this.top, this.left);\n  }\n  get topRight() {\n    return new _Vector.Vector2(this.top, this.right);\n  }\n  get bottomLeft() {\n    return new _Vector.Vector2(this.bottom, this.left);\n  }\n  get bottomRight() {\n    return new _Vector.Vector2(this.bottom, this.right);\n  }\n  get x() {\n    return this.position.x;\n  }\n  set x(n) {\n    if (MY.isNumber(n)) this.position.x = n;\n  }\n  get y() {\n    return this.position.y;\n  }\n  set y(n) {\n    if (MY.isNumber(n)) this.position.y = n;\n  }\n  get w() {\n    return this.size.x;\n  }\n  set w(n) {\n    if (MY.isNumber(n)) this.size.x = n;\n  }\n  get h() {\n    return this.size.y;\n  }\n  set h(n) {\n    if (MY.isNumber(n)) this.size.y = n;\n  }\n  get left() {\n    return this.x;\n  }\n  set left(n) {\n    if (MY.isNumber(n)) {\n      this.w = this.right - n;\n      this.x = n;\n    }\n  }\n  get top() {\n    return this.y;\n  }\n  set top(n) {\n    if (MY.isNumber(n)) {\n      this.h = this.bottom - n;\n      this.y = n;\n    }\n  }\n  get right() {\n    return this.x + this.w;\n  }\n  set right(n) {\n    if (MY.isNumber(n)) {\n      this.w = n - this.left;\n    }\n  }\n  get bottom() {\n    return this.y + this.h;\n  }\n  set bottom(n) {\n    if (MY.isNumber(n)) {\n      this.h = n - this.top;\n    }\n  }\n  constructor(p, s, w, h) {\n    if (p instanceof Rect2) {\n      this.position = new _Vector.Vector2(p.position);\n      this.size = new _Vector.Vector2(p.size);\n    } else if (MY.isObject(p) && 'x' in p && 'y' in p && 'w' in p && 'h' in p) {\n      this.position = new _Vector.Vector2(p.x, p.y);\n      this.size = new _Vector.Vector2(p.w, p.h);\n    } else if (MY.isObject(p) && 'top' in p && 'left' in p && 'right' in p && 'bottom' in p) {\n      this.position = new _Vector.Vector2(p.left, p.top);\n      this.size = new _Vector.Vector2(p.right - p.left, p.bottom - p.top);\n    } else if (MY.isObject(p) && 't' in p && 'l' in p && 'r' in p && 'b' in p) {\n      this.position = new _Vector.Vector2(p.l, p.t);\n      this.size = new _Vector.Vector2(p.r - p.l, p.b - p.t);\n    } else if (MY.isNumber(p) && MY.isNumber(s) && MY.isNumber(w) && MY.isNumber(h)) {\n      this.position = new _Vector.Vector2(p, s);\n      this.size = new _Vector.Vector2(w, h);\n    } else if (p instanceof _Vector.Vector2 && s instanceof _Vector.Vector2) {\n      this.position = new _Vector.Vector2(p);\n      this.size = new _Vector.Vector2(s);\n    } else {\n      this.position = new _Vector.Vector2();\n      this.size = new _Vector.Vector2();\n    }\n  }\n  abs() {\n    return new Rect2(this.position, this.size.abs());\n  }\n  containsPoint(v) {\n    if (v.x < this.left || v.x > this.right || v.y < this.top || v.y > this.bottom) return false;\n    return true;\n  }\n  getIntersectWith(other, threshold = 0) {\n    if (!this.intersectsWith(other, threshold)) return null;\n    let yMin = this.top > other.top ? this.top : other.top;\n    let yMax = this.bottom < other.bottom ? this.bottom : other.bottom;\n    let xMin = this.left > other.left ? this.left : other.left;\n    let xMax = this.right < other.right ? this.right : other.right;\n    return new Rect2(new _Vector.Vector2(xMin, yMin), new _Vector.Vector2(xMax - xMin, yMax - yMin));\n  }\n  intersectsWith(other, threshold = 0) {\n    if (this.right + threshold < other.left || this.left - threshold > other.right || this.bottom + threshold < other.top || this.top - threshold > other.bottom) return false;\n    return true;\n  }\n  touches(other, threshold = 0) {\n    if (this.right + threshold == other.left || this.left - threshold == other.right || this.bottom + threshold == other.top || this.top - threshold == other.bottom) return true;\n    return false;\n  }\n  combine(other) {\n    let pts = this.getCorners().concat(other.getCorners());\n    return Rect2.getFromPoints(pts);\n  }\n  getCorners() {\n    return [this.topLeft, this.topRight, this.bottomRight, this.bottomLeft];\n  }\n  asObject() {\n    let rect = {};\n    rect = {\n      x: this.x,\n      y: this.y,\n      w: this.w,\n      h: this.h,\n      get top() {\n        return rect.y;\n      },\n      get bottom() {\n        return rect.y + rect.h;\n      },\n      get left() {\n        return rect.x;\n      },\n      get right() {\n        return rect.x + rect.w;\n      }\n    };\n    return rect;\n  }\n  asArray() {\n    return [this.x, this.y, this.w, this.h];\n  }\n  toString() {\n    var out = `Rect2( ${this.position} ${this.size})`;\n    return out;\n  }\n}\nexports.Rect2 = Rect2;\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Rect2/Rect2.js?");

/***/ }),

/***/ "./lib/cjs/src/Transform2/Transform2.js":
/*!**********************************************!*\
  !*** ./lib/cjs/src/Transform2/Transform2.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Transform2 = void 0;\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.min.js\"));\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \"./lib/cjs/src/Vector2/Vector2.js\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass Transform2 {\n  _position;\n  _rotation;\n  _scale;\n  _skew;\n  _anchor;\n  _parent;\n  _childs = [];\n  get parent() {\n    return this._parent;\n  }\n  set parent(x) {\n    if (x instanceof Transform2) this._parent = x;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(x) {\n    if (x instanceof _Vector.Vector2) this._position = x;\n  }\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(x) {\n    if (MY.isNumber(x)) this._rotation = Number(x);\n  }\n  get scale() {\n    return this._scale;\n  }\n  set scale(x) {\n    if (x instanceof _Vector.Vector2) this._scale = x;\n  }\n  get skew() {\n    return this._skew;\n  }\n  set skew(x) {\n    if (x instanceof _Vector.Vector2) this._skew = x;\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(x) {\n    if (x instanceof _Vector.Vector2) this._anchor = x;\n  }\n  get children() {\n    return this._childs;\n  }\n  get childs() {\n    return this.children;\n  }\n  get a() {\n    return this.scale.x * (Math.cos(this.rotation) - Math.sin(this.rotation) * Math.tan(this.skew.x));\n  }\n  get b() {\n    return this.scale.y * (Math.sin(this.rotation) + Math.cos(this.rotation) * Math.tan(this.skew.y));\n  }\n  get c() {\n    return this.scale.x * (Math.cos(this.rotation) * Math.tan(this.skew.x) - Math.sin(this.rotation));\n  }\n  get d() {\n    return this.scale.y * (Math.sin(this.rotation) * Math.tan(this.skew.y) + Math.cos(this.rotation));\n  }\n  get tx() {\n    return this.position.x;\n  }\n  get ty() {\n    return this.position.y;\n  }\n  get matrix() {\n    return [[this.a, this.c, this.tx], [this.b, this.d, this.ty], [0, 0, 1]];\n  }\n  constructor(p = _Vector.Vector2.ZERO, r = 0, s = _Vector.Vector2.ONE, k = _Vector.Vector2.ZERO, a = _Vector.Vector2.ZERO) {\n    if (p instanceof Transform2) {\n      this.position = new _Vector.Vector2(p.position);\n      this.rotation = Number(p.rotation);\n      this.scale = new _Vector.Vector2(p.scale);\n      this.skew = new _Vector.Vector2(p.skew);\n      this.anchor = new _Vector.Vector2(p.anchor);\n    } else {\n      this.position = new _Vector.Vector2(p);\n      this.rotation = Number(r);\n      this.scale = new _Vector.Vector2(s);\n      this.skew = new _Vector.Vector2(k);\n      this.anchor = new _Vector.Vector2(a);\n    }\n  }\n  setParent(x) {\n    if (!(x instanceof Transform2)) return;\n    if (x == this) return;\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.parent = x;\n  }\n  addChild(x) {\n    if (!(x instanceof Transform2)) return;\n    if (x == this) return;\n    x.setParent(this);\n    this._childs.push(x);\n  }\n  removeChild(x) {\n    if (x == this) return null;\n    let ind;\n    let out = null;\n    if (x instanceof Transform2) ind = this._childs.indexOf(x);else if (MY.isNumber(x)) {\n      ind = x;\n    }\n    if (ind >= 0 && ind < this._childs.length) {\n      out = this._childs[ind];\n      this._childs.splice(ind, 1);\n    }\n    return out;\n  }\n  getComputedTransform() {\n    let parentTransform = this.parent?.getComputedTransform() || new Transform2();\n    let pt = parentTransform;\n    let p = _Vector.Vector2.ADD(pt.position, this.position);\n    let r = pt.rotation + this.rotation;\n    let s = _Vector.Vector2.MULTIPLY(pt.scale, this.scale);\n    let k = new _Vector.Vector2(Math.tan(Math.atan(this.skew.x) + Math.atan(pt.skew.x)), Math.tan(Math.atan(this.skew.y) + Math.atan(pt.skew.y)));\n    let a = _Vector.Vector2.ADD(pt.anchor, this.anchor);\n    return new Transform2(p, r, s, k, a);\n  }\n  applyComputedTransform(pt) {\n    let cpt = this.getComputedTransform();\n    let newPt = new _Vector.Vector2(pt);\n\n    // newPt = Vector2.SUBTRACT(newPt, this.anchor);\n    newPt = cpt.applyTransform(pt, this.anchor);\n    // newPt = Vector2.ADD(newPt, this.anchor);\n\n    return newPt;\n  }\n  applyTranslate(pt, anchor = this.anchor) {\n    let newPt = new _Vector.Vector2(pt);\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\n    newPt = _Vector.Vector2.ADD(newPt, this.position);\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\n    return newPt;\n  }\n  applyRotate(pt, anchor = this.anchor) {\n    let newPt = new _Vector.Vector2(pt);\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\n    newPt = newPt.rotated(_Vector.Vector2.ZERO, this.rotation);\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\n    return newPt;\n  }\n  applySkew(pt, anchor = this.anchor) {\n    let newPt = new _Vector.Vector2(pt);\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\n    newPt = newPt.skewed(_Vector.Vector2.ZERO, this.skew);\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\n    return newPt;\n  }\n  applyScale(pt, anchor = this.anchor) {\n    let newPt = new _Vector.Vector2(pt);\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\n    newPt = _Vector.Vector2.MULTIPLY(newPt, this.scale);\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\n    return newPt;\n  }\n  applyTransform(pt, anchor = this.anchor, order = ['T', 'R', 'K', 'S']) {\n    let newPt = new _Vector.Vector2(pt);\n    newPt = _Vector.Vector2.SUBTRACT(newPt, anchor);\n    for (let trans of order) {\n      if (!trans) continue;\n      switch (trans?.toUpperCase()) {\n        case 'T':\n        case 'TRANSLATE':\n        case 'POSITION':\n          newPt = this.applyTranslate(newPt, _Vector.Vector2.ZERO);\n          break;\n        case 'R':\n        case 'ROTATE':\n        case 'ROTATION':\n          newPt = this.applyRotate(newPt, _Vector.Vector2.ZERO);\n          break;\n        case 'K':\n        case 'SKEW':\n          newPt = this.applySkew(newPt, _Vector.Vector2.ZERO);\n          break;\n        case 'S':\n        case 'SCALE':\n        case 'SIZE':\n          newPt = this.applyScale(newPt, _Vector.Vector2.ZERO);\n          break;\n        default:\n          newPt = newPt;\n          break;\n      }\n    }\n    newPt = _Vector.Vector2.ADD(newPt, anchor);\n    return newPt;\n\n    // let translate = this.position;\n    // let scale = this.scale;\n    // let rotate = this.rotation;\n    // let skew = this.skew;\n    // let anchor = this.anchor;\n\n    // let a = (scale.x) * ( Math.cos(rotate) - (Math.sin(rotate) * Math.tan(skew.x)) );\n    // let b = (scale.y) * ( Math.sin(rotate) + (Math.cos(rotate) * Math.tan(skew.y)) );\n    // let c = (scale.x) * ( (Math.cos(rotate) * Math.tan(skew.x)) - Math.sin(rotate) );\n    // let d = (scale.y) * ( (Math.sin(rotate) * Math.tan(skew.y)) + Math.cos(rotate) );\n\n    // let tx = translate.x; let ty = translate.y;\n\n    // let ax = anchor.x; let ay = anchor.y;\n\n    // let vx = pt.x; let vy = pt.y;\n\n    // let Rx = ((a*(vx-ax)) + (c*(vy-ay)) + tx) + ax;\n    // let Ry = ((b*(vx-ax)) + (d*(vy-ay)) + ty) + ay;\n\n    // return new Vector2(Rx,Ry);\n  }\n}\n\nexports.Transform2 = Transform2;\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Transform2/Transform2.js?");

/***/ }),

/***/ "./lib/cjs/src/Vector2Line/Vector2Line.js":
/*!************************************************!*\
  !*** ./lib/cjs/src/Vector2Line/Vector2Line.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Vector2Line = void 0;\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.min.js\"));\nvar _Vector = __webpack_require__(/*! ../Vector2/Vector2 */ \"./lib/cjs/src/Vector2/Vector2.js\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass Vector2Line {\n  a;\n  b;\n  c;\n  // f //x intercept\n  // e //y intercept\n  // m //gradient\n\n  get gradient() {\n    return MY.safeDivide(-this.a, this.b);\n  }\n  get m() {\n    return this.gradient;\n  }\n  get xIntercept() {\n    return MY.safeDivide(-this.c, this.a);\n  }\n  get f() {\n    return this.xIntercept;\n  }\n  get yIntercept() {\n    return MY.safeDivide(-this.c, this.b);\n  }\n  get e() {\n    return this.yIntercept;\n  }\n  constructor(x, y) {\n    if (x instanceof _Vector.Vector2 && y instanceof _Vector.Vector2 || MY.isObject(x) && MY.isObject(y) || MY.isArray(x) && MY.isArray(y)) {\n      //make line that passes through these points\n      let a, b, c;\n      let v1 = new _Vector.Vector2(x.x || x[0] || 0, x.y || x[1] || 0);\n      let v2 = new _Vector.Vector2(y.x || y[0] || 0, y.y || y[1] || 0);\n      let m = _Vector.Vector2.SUBTRACT(v2, v1).gradient();\n\n      //y=mx+e\n      //e = y - mx\n\n      let e, f;\n      if (MY.isInfinity(m)) {\n        //vertical line\n        c = -(v1.x || v2.x);\n        b = 0;\n        a = -1;\n      } else if (m == 0) {\n        //horizontal line\n        a = 0;\n        b = -1;\n        c = -(v1.y || v2.y);\n      } else {\n        e = v1.y - m * v1.x;\n        f = MY.safeDivide(-e, m);\n        c = -(f * m);\n        b = MY.safeDivide(-c, e) || 1;\n        a = -(b * m);\n\n        //\n      }\n\n      //finish and account for vertical and horizontal lines\n\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    } else if (MY.isObject(x) && 'a' in x && 'b' in x && 'c' in x) {\n      //use standard form\n      let obj = x;\n      this.a = obj.a;\n      this.b = obj.b;\n      this.c = obj.c;\n    } else if (MY.isObject(x) && ('gradient' in x || 'm' in x) && ('e' in x || 'c' in x || 'yIntercept' in x)) {\n      //use intercept form\n      let obj = x;\n      let a, b, c;\n      let m = obj.gradient || obj.m || 0;\n      let e = obj.e || obj.c || obj.yIntercept || 0;\n      let f;\n      if ('f' in obj || 'xIntercept' in obj) {\n        f = obj.f || obj.xIntercept || 0;\n        c = -(f * m);\n      } else {\n        c = 1;\n        f = MY.safeDivide(-c, m);\n      }\n      b = MY.safeDivide(-c, e);\n      a = -(b * m);\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    } else if (MY.isObject(x) && ('f' in x || 'x' in x || 'c' in x || 'xIntercept' in x) && ('e' in x || 'y' in x || 'yIntercept' in x)) {\n      //use intercept form but with actual intercepts\n      let obj = x;\n      let a, b, c;\n      let e = obj.e || obj.c || obj.y || obj.yIntercept || 0;\n      let f = obj.f || obj.x || obj.xIntercept || 0;\n      let m = new _Vector.Vector2(0 - e, f - 0).gradient();\n      c = -(f * m);\n      b = MY.safeDivide(-c, e);\n      a = -(b * m);\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    } else if (MY.isNumber(x) && MY.isNumber(y)) {\n      //treat as x and y intercepts\n\n      let a, b, c;\n      let e = y;\n      let f = x;\n      let m = new _Vector.Vector2(0 - e, f - 0).gradient();\n      c = -(f * m);\n      b = MY.safeDivide(-c, e);\n      a = -(b * m);\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n  }\n  getX(y) {\n    let x;\n    if (this.b != 0) {\n      let m = this.gradient;\n      let e = this.yIntercept;\n\n      //y = mx+e\n      //x = (y - e)/m\n\n      x = MY.safeDivide(y - e, m);\n    } else {\n      let c = this.c;\n      let a = this.a;\n      x = MY.safeDivide(-c, a);\n    }\n    return x;\n  }\n  getY(x) {\n    let y;\n    if (this.a != 0) {\n      let m = this.gradient;\n      let e = this.yIntercept;\n\n      //y = mx+e\n      //x = (y - e)/m\n\n      y = m * x + e;\n    } else {\n      let c = this.c;\n      let b = this.b;\n      y = MY.safeDivide(-c, b);\n    }\n    return y;\n  }\n  equals(other) {\n    return this.gradient == other.gradient && this.yIntercept == other.yIntercept && this.xIntercept == other.xIntercept;\n  }\n  isHorizontal() {\n    return this.a === 0;\n  }\n  isVertical() {\n    return this.b === 0;\n  }\n  hasPoint(point) {\n    let v = new _Vector.Vector2(point);\n\n    //ax+by+c=0\n\n    let res;\n    if (MY.isInfinity(this.a) && MY.isInfinity(this.b)) {\n      if (a == b) {\n        // INF + INF\n        res = Infinity + this.c;\n      } else {\n        // INF - INF\n        res = 0 + this.c;\n      }\n    } else {\n      let ax = this.a * v.x;\n      let by = this.b * v.y;\n      let c = this.c;\n      res = ax + by + c;\n      res = Number(res);\n    }\n    return res == 0;\n  }\n  angle() {\n    let xInt = this.xIntercept;\n    let yInt = this.yIntercept;\n    if (xInt == Infinity) return 0; //or Math.PI\n    if (xInt == -Infinity) return Math.PI; //or Math.PI\n    if (yInt == Infinity) return Math.PI / 2;\n    if (yInt == -Infinity) return -(Math.PI / 2);\n    let vx = new _Vector.Vector2(xInt, 0);\n    let vy = new _Vector.Vector2(0, yInt);\n    return vx.angleToPoint(vy);\n  }\n  intersect(other) {\n    //x = (b1c2-b2c1)/(a1b2-a2b1) = BC/AB\n    //y = (a2c1-a1c2)/(a1b2-a2b1) = AC/AB\n\n    if (other.gradient == this.gradient) {\n      return null;\n    }\n    let a1 = this.a,\n      a2 = other.a;\n    let b1 = this.b,\n      b2 = other.b;\n    let c1 = this.c,\n      c2 = other.c;\n    let b1c2 = b1 * c2;\n    let b2c1 = b2 * c1;\n    let a1b2 = a1 * b2;\n    let a2b1 = a2 * b1;\n    let a2c1 = a2 * c1;\n    let a1c2 = a1 * c2;\n    let BC, AB, AC;\n    if (MY.isInfinity(b1c2) && MY.isInfinity(b2c1) && b1c2 != b2c1) {\n      BC = 0;\n    } else {\n      BC = b1c2 - b2c1;\n    }\n    if (MY.isInfinity(a1b2) && MY.isInfinity(a2b1) && a1b2 != a2b1) {\n      AB = 0;\n    } else {\n      AB = a1b2 - a2b1;\n    }\n    if (MY.isInfinity(a2c1) && MY.isInfinity(a1c2) && a2c1 != a1c2) {\n      AC = 0;\n    } else {\n      AC = a2c1 - a1c2;\n    }\n\n    // console.log({BC,AB,AC, l1:this,l2:other})\n\n    let x = MY.safeDivide(BC, AB);\n    let y = MY.safeDivide(AC, AB);\n\n    // console.log({x,y})\n\n    return new _Vector.Vector2(x, y);\n  }\n  perpendicular(point) {\n    point = new _Vector.Vector2(point);\n    if (this.a == 0) {\n      let a = this.b,\n        b = this.a,\n        c = point.x;\n      return new Vector2Line({\n        a,\n        b,\n        c\n      });\n    } else if (this.b == 0) {\n      let a = this.b,\n        b = this.a,\n        c = point.y;\n      return new Vector2Line({\n        a,\n        b,\n        c\n      });\n    } else {\n      let m = MY.safeDivide(-1, this.gradient);\n      let e = point.y + 1 / m * point.x;\n      let f = MY.safeDivide(-e, m);\n      return new Vector2Line({\n        gradient: m,\n        xIntercept: f,\n        yIntercept: f\n      });\n    }\n  }\n  normal() {\n    return new _Vector.Vector2(this.a, this.b);\n  }\n  mirror(point) {\n    point = new _Vector.Vector2(point);\n    if (this.hasPoint(point)) {\n      return new _Vector.Vector2(point);\n    }\n    let _normal = this.normal();\n    let unitNormal = _normal.normalized();\n    let unitC = MY.safeDivide(this.c, _normal.length());\n    let signedDist = unitNormal.x * point.x + unitNormal.y * point.y + unitC;\n    let mx = point.x - 2 * unitNormal.x * signedDist;\n    let my = point.y - 2 * unitNormal.y * signedDist;\n    return new _Vector.Vector2(mx, my);\n  }\n}\nexports.Vector2Line = Vector2Line;\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Vector2Line/Vector2Line.js?");

/***/ }),

/***/ "./lib/cjs/src/Vector2/Vector2.js":
/*!****************************************!*\
  !*** ./lib/cjs/src/Vector2/Vector2.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Vector2 = void 0;\nvar MY = _interopRequireWildcard(__webpack_require__(/*! @catsums/my */ \"./node_modules/@catsums/my/lib/umd/index.min.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass Vector2 {\n  x;\n  y;\n  static get ZERO() {\n    return new Vector2(0, 0);\n  }\n  static get ONE() {\n    return new Vector2(1, 1);\n  }\n  static get NEG_ONE() {\n    return new Vector2(-1, -1);\n  }\n  static get INF() {\n    return new Vector2(Infinity, Infinity);\n  }\n  static get NEG_INF() {\n    return new Vector2(-Infinity, -Infinity);\n  }\n  static get EPSILON() {\n    return new Vector2(Number.MIN_VALUE, Number.MIN_VALUE);\n  }\n  static get UP() {\n    return new Vector2(0, -1);\n  }\n  static get DOWN() {\n    return new Vector2(0, 1);\n  }\n  static get LEFT() {\n    return new Vector2(-1, 0);\n  }\n  static get RIGHT() {\n    return new Vector2(1, 0);\n  }\n  static ADD(v1, v2) {\n    return new Vector2(v1.x + v2.x, v1.y + v2.y);\n  }\n  add(other) {\n    this.x += other.x;\n    this.y += other.y;\n  }\n  static SUBTRACT(v1, v2) {\n    return new Vector2(v1.x - v2.x, v1.y - v2.y);\n  }\n  subtract(other) {\n    this.x -= other.x;\n    this.y -= other.y;\n  }\n  static MULTIPLY(v1, v2) {\n    if (MY.isNumber(v2)) v2 = new Vector2(v2, v2);\n    return new Vector2(v1.x * v2.x, v1.y * v2.y);\n  }\n  multiply(other) {\n    if (MY.isNumber(other)) {\n      return this.scale(other);\n    }\n    this.x *= other.x;\n    this.y *= other.y;\n  }\n  static DIVIDE(v1, v2) {\n    return new Vector2(v1.x / v2.x, v1.y / v2.y);\n  }\n  divide(other) {\n    this.x /= other.x;\n    this.y /= other.y;\n  }\n  static SCALE(v1, n) {\n    return new Vector2(v1.x * n, v1.y * n);\n  }\n  scaleBy(n) {\n    this.x *= n;\n    this.y *= n;\n  }\n  scaled(n) {\n    return new Vector2(this.x * n, this.y * n);\n  }\n  static MOD(v1, v2) {\n    return new Vector2(mod(v1.x, v2.x), mod(v1.y, v2.y));\n  }\n  mod(other) {\n    this.x = mod(this.x, other.x);\n    this.y = mod(this.y, other.y);\n  }\n  static MODBY(v1, n) {\n    return new Vector2(mod(v1.x, n), mod(v1.y, n));\n  }\n  modBy(n) {\n    this.x = mod(this.x, n);\n    this.y = mod(this.y, n);\n  }\n  static DOT(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  static EQUALS(v1, v2) {\n    if (!v1 && !v2) return true;\n    if (v1?.x === v2?.x && v1?.y === v2?.y) return true;\n    if (Math.abs(v1?.x - v2?.x) < Number.EPSILON && Math.abs(v1?.y - v2?.y) < Number.EPSILON) {\n      return true;\n    }\n    return false;\n  }\n  equals(other) {\n    return Vector2.EQUALS(this, other);\n  }\n  static SortAlgo(a, b) {\n    if (a.isGreaterThan(b)) return 1;else if (a.isLesserThan(b)) return -1;\n    return 0;\n  }\n  static SortAlgoX(a, b) {\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\n    return 0;\n  }\n  static SortAlgoY(a, b) {\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\n    return 0;\n  }\n  static SortAlgoXY(a, b) {\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\n    return 0;\n  }\n  static SortAlgoXY(a, b) {\n    if (a.y > b.y) return 1;else if (a.y < b.y) return -1;\n    if (a.x > b.x) return 1;else if (a.x < b.x) return -1;\n    return 0;\n  }\n  static SortAlgoAvg(a, b) {\n    let x, y;\n    if (a.x > b.x) x = 1;else if (a.x < b.x) x = -1;else x = 0;\n    if (a.y > b.y) y = 1;else if (a.y < b.y) y = -1;else y = 0;\n    let avg = x + y / 2;\n    return Math.trunc(avg);\n  }\n  constructor(x = 0, y = 0) {\n    if (x instanceof Vector2 || MY.isObject(x) && 'x' in x && 'y' in x) {\n      this.x = x.x;\n      this.y = x.y;\n    } else if (MY.isArray(x) && MY.isNumber(x[0]) && MY.isNumber(x[1])) {\n      this.x = x[0];\n      this.y = x[1];\n    } else if (MY.isNumber(x) && MY.isNumber(y)) {\n      this.x = x;\n      this.y = y;\n    } else {\n      this.x = 0;\n      this.y = 0;\n    }\n  }\n  abs() {\n    var v = new Vector2(Math.abs(this.x), Math.abs(this.y));\n    return v;\n  }\n  lengthSquared() {\n    var llengthSquared = Math.pow(this.x, 2) + Math.pow(this.y, 2);\n    return llengthSquared;\n  }\n  length() {\n    return Math.sqrt(this.lengthSquared());\n  }\n  lerp(other, t) {\n    let x = this.x + (other.x - this.x) * t;\n    let y = this.y + (other.y - this.y) * t;\n    return new Vector2(x, y);\n  }\n  sumOfParts() {\n    return this.x + this.y;\n  }\n  ratioed() {\n    var sum = this.sumOfParts();\n    return new Vector2(MY.safeDivide(this.x, sum), MY.safeDivide(this.y, sum));\n  }\n  isNormalised() {\n    return Math.abs(this.lengthSquared() - 1) == 0;\n  }\n  normalized() {\n    var llen = this.length();\n    return new Vector2(MY.safeDivide(this.x, llen), MY.safeDivide(this.y, llen));\n  }\n  normalised() {\n    return this.normalized();\n  }\n  magnitude() {\n    return this.length();\n  }\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n  lineTo(other) {\n    return Vector2.SUBTRACT(other, this);\n  }\n  gradient() {\n    return MY.safeDivide(this.y, this.x);\n  }\n  angle() {\n    let prod = MY.safeDivide(this.y, this.x);\n    return Math.atan(prod);\n  }\n  angleTo(other) {\n    return this.angle() - other.angle();\n  }\n  angleToPoint(other) {\n    return this.lineTo(other).angle();\n  }\n  angleBetween(a, b) {\n    //p1 = c, p2 = a, p3 = b\n    let c = new Vector2(this);\n    let top = a.y * (c.x - b.x) + c.y * (b.x - a.x) + b.y * (a.x - c.x);\n    let bot = (a.x - c.x) * (c.x - b.x) + (a.y - c.y) * (c.y - b.y);\n    let ratio = MY.safeDivide(top, bot);\n    let angle = Math.atan(ratio);\n    return angle;\n  }\n  distanceSquaredTo(other) {\n    return Vector2.SUBTRACT(other, this).lengthSquared();\n  }\n  distanceTo(other) {\n    return Vector2.SUBTRACT(other, this).length();\n  }\n  directionTo(other) {\n    return Vector2.SUBTRACT(other, this).normalized();\n  }\n  rotateAround(pivot, angle) {\n    let pt = new Vector2(this);\n    let ct = new Vector2(pivot);\n    let sinO = Math.sin(angle);\n    let cosO = Math.cos(angle);\n    pt.x -= ct.x;\n    pt.y -= ct.y;\n    this.x = pt.x * cosO - pt.y * sinO + ct.x;\n    this.y = pt.x * sinO + pt.y * cosO + ct.y;\n  }\n  rotated(pivot, angle) {\n    let pt = new Vector2(this);\n    let ct = new Vector2(pivot);\n    let sinO = Math.sin(angle);\n    let cosO = Math.cos(angle);\n    pt.x -= ct.x;\n    pt.y -= ct.y;\n    let _x = pt.x * cosO - pt.y * sinO + ct.x;\n    let _y = pt.x * sinO + pt.y * cosO + ct.y;\n    return new Vector2(_x, _y);\n  }\n  skewed(pivot, skewer) {\n    let pt = new Vector2(this);\n    let ct = new Vector2(pivot);\n    pt.x -= ct.x;\n    pt.y -= ct.y;\n    let _x = pt.x + pt.y * skewer.x + ct.x;\n    let _y = pt.x * skewer.y + pt.y + ct.y;\n    return new Vector2(_x, _y);\n  }\n  skew(pivot, skewer) {\n    let pt = new Vector2(this);\n    let ct = new Vector2(pivot);\n    pt.x -= ct.x;\n    pt.y -= ct.y;\n    this.x = pt.x + pt.y * skewer.x + ct.x;\n    this.y = pt.x * skewer.y + pt.y + ct.y;\n  }\n  static INVERSE(v1) {\n    return v1.inverse();\n  }\n  inverse() {\n    let ix, iy;\n    if (this.x === 0) ix = Infinity;else if (this.x === Infinity || this.x === -Infinity) ix = 0;else ix = 1 / this.x;\n    if (this.y === 0) iy = Infinity;else if (this.y === Infinity || this.y === -Infinity) iy = 0;else iy = 1 / this.y;\n    return new Vector2(ix, iy);\n  }\n  static FLIPPED(v1) {\n    return new Vector2(v1.y, v1.x);\n  }\n  flipped() {\n    return new Vector2(this.y, this.x);\n  }\n  static MIDPOINT(arr) {\n    if (!MY.isArray(arr)) {\n      arr = [];\n    }\n    let _x = 0,\n      _y = 0;\n    for (let v of arr) {\n      v = new Vector2(v);\n      _x += v.x;\n      _y += v.y;\n    }\n    let x = MY.safeDivide(_x, arr.length);\n    let y = MY.safeDivide(_y, arr.length);\n    return new Vector2(x, y);\n  }\n  midPoint(other) {\n    let arr = [];\n    if (!MY.isArray(other)) {\n      arr.push(other);\n    } else {\n      arr = arr.concat(other);\n    }\n    let _x = 0,\n      _y = 0;\n    for (let v of arr) {\n      v = new Vector2(v);\n      _x += v.x;\n      _y += v.y;\n    }\n    _x += this.x;\n    _y += this.y;\n    let x = MY.safeDivide(_x, arr.length + 1);\n    let y = MY.safeDivide(_y, arr.length + 1);\n    return new Vector2(x, y);\n  }\n  floor() {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  }\n  ceil() {\n    return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\n  }\n  reflect(other) {\n    return Vector2.SUBTRACT(this, Vector2.SCALE(other, 2 * Vector2.DOT(this, other)));\n  }\n  project(norm) {\n    return Vector2.SCALE(norm, this.dot(norm) / norm.lengthSquared());\n  }\n  slide(other) {\n    return Vector2.SUBTRACT(this, Vector2.SCALE(other, this.dot(other)));\n  }\n  bounce(other) {\n    return Vector2.NEG(this.reflect(other));\n  }\n  closestPoint(arr, exclusive = false) {\n    if (!MY.isArray(arr) || !arr.length) return null;\n    let pt = null;\n    let dist = Infinity;\n    for (let v of arr) {\n      if (exclusive && v.equals(this)) {\n        continue;\n      }\n      let _dist = Math.abs(v.distanceTo(this));\n      if (_dist < dist) {\n        pt = v;\n        dist = _dist;\n      }\n    }\n    return pt;\n  }\n  sortPointsByClosest(points) {\n    if (!MY.isArray(points)) return null;\n    let arr = points.slice();\n    let len = arr.length;\n    let newArr = [];\n    // console.log({arr,len,points,newArr})\n    for (let i = 0; i < len; i++) {\n      let pt = this.closestPoint(arr);\n      // console.log({pt})\n      if (!pt) continue;\n      newArr.push(pt);\n      let index = arr.indexOf(pt);\n      arr.splice(index, 1);\n      // MY.arrayRemove(arr, pt);\n      i--;\n    }\n    return newArr;\n  }\n  toString() {\n    var out = \"( \" + String(this.x) + \" , \" + String(this.y) + \" )\";\n    return out;\n  }\n  asObject() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n  asArray() {\n    return [this.x, this.y];\n  }\n  isGreaterThan(other) {\n    return this.lengthSquared() > other.lengthSquared();\n  }\n  isLesserThan(other) {\n    return this.lengthSquared() < other.lengthSquared();\n  }\n  static NEG(v1) {\n    return new Vector2(-v1.x, -v1.y);\n  }\n  neg() {\n    return Vector2.NEG(this);\n  }\n  static quadraticBezier(points, t) {\n    let qPoints = [];\n    for (let i = 0; i < points.length - 1; i++) {\n      let pA = new Vector2(points[i]);\n      let pB = new Vector2(points[i + 1]);\n      let pt = pA.lerp(pB, t);\n      qPoints.push(pt);\n    }\n    if (qPoints.length < 2) {\n      return qPoints[0];\n    }\n    return Vector2.quadraticBezier(qPoints, t);\n  }\n  static quadraticBezierPoints(points, inc) {\n    let qPoints = [];\n    if (MY.isArray(points) && MY.isNumber(inc) && inc > 0) {\n      let t = 0;\n      let last = false;\n      while (t <= 1) {\n        qPoints.push(Vector2.quadraticBezier(points, t));\n        t += inc;\n        if (t > 1 && !last) {\n          t = 1;\n          last = true;\n        }\n      }\n    }\n    return qPoints;\n  }\n}\nexports.Vector2 = Vector2;\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/Vector2/Vector2.js?");

/***/ }),

/***/ "./lib/cjs/src/index.js":
/*!******************************!*\
  !*** ./lib/cjs/src/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Vector = __webpack_require__(/*! ./Vector2/Vector2 */ \"./lib/cjs/src/Vector2/Vector2.js\");\nvar _Vector2Line = __webpack_require__(/*! ./Vector2Line/Vector2Line */ \"./lib/cjs/src/Vector2Line/Vector2Line.js\");\nvar _Rect = __webpack_require__(/*! ./Rect2/Rect2 */ \"./lib/cjs/src/Rect2/Rect2.js\");\nvar _Transform = __webpack_require__(/*! ./Transform2/Transform2 */ \"./lib/cjs/src/Transform2/Transform2.js\");\nmodule.exports = {\n  Vector2: _Vector.Vector2,\n  Vector2Line: _Vector2Line.Vector2Line,\n  Rect2: _Rect.Rect2,\n  Transform2: _Transform.Transform2\n};\n\n//# sourceURL=webpack://VECTOR2/./lib/cjs/src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/cjs/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});