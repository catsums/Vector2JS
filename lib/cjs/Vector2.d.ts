declare global {
    interface IVector2 {
        x: number;
        y: number;
    }
}
export declare class Vector2 implements IVector2 {
    x: number;
    y: number;
    static get ZERO(): Vector2;
    static get ONE(): Vector2;
    static get NEG_ONE(): Vector2;
    static get INF(): Vector2;
    static get NEG_INF(): Vector2;
    static get EPSILON(): Vector2;
    static get UP(): Vector2;
    static get DOWN(): Vector2;
    static get LEFT(): Vector2;
    static get RIGHT(): Vector2;
    static ADD(v1: IVector2, v2: IVector2): Vector2;
    add(other: IVector2): void;
    static SUBTRACT(v1: IVector2, v2: IVector2): Vector2;
    subtract(other: IVector2): void;
    static MULTIPLY(v1: IVector2, v2: number | IVector2): Vector2;
    multiply(other: number | IVector2): Vector2;
    static DIVIDE(v1: IVector2, v2: number | IVector2): Vector2;
    divide(other: number | IVector2): Vector2;
    static SCALE(v1: any, n: any): Vector2;
    scaleBy(n: number): void;
    scaled(n: number): Vector2;
    static MOD(v1: IVector2, v2: IVector2): Vector2;
    mod(other: IVector2): void;
    static MODBY(v1: IVector2, n: number): Vector2;
    modBy(n: number): void;
    static DOT(v1: IVector2, v2: IVector2): number;
    static EQUALS(v1: IVector2, v2: IVector2, precision?: number): boolean;
    equals(other: IVector2, precision?: number): boolean;
    static SortAlgo(a: Vector2, b: Vector2): 0 | 1 | -1;
    static SortAlgoX(a: Vector2, b: Vector2): 0 | 1 | -1;
    static SortAlgoY(a: Vector2, b: Vector2): 0 | 1 | -1;
    static SortAlgoXY(a: Vector2, b: Vector2): 0 | 1 | -1;
    static SortAlgoYX(a: Vector2, b: Vector2): 0 | 1 | -1;
    static SortAlgoAvg(a: Vector2, b: Vector2): number;
    constructor(x: number, y: number);
    constructor([x, y]: [number, number]);
    constructor(v: IVector2);
    constructor();
    abs(): Vector2;
    lengthSquared(): number;
    length(): number;
    lerp(other: IVector2, t: number): Vector2;
    sumOfParts(): number;
    ratioed(): Vector2;
    isNormalised(): boolean;
    normalized(): Vector2;
    normalised(): Vector2;
    magnitude(): number;
    dot(other: IVector2): number;
    lineTo(other: IVector2): Vector2;
    gradient(): number;
    angle(): number;
    angleTo(other: IVector2): number;
    angleToPoint(other: IVector2): number;
    angleBetween(a: IVector2, b: IVector2): number;
    distanceSquaredTo(other: IVector2): number;
    distanceTo(other: IVector2): number;
    directionTo(other: IVector2): Vector2;
    rotateAround(pivot: IVector2, angle: number): void;
    rotated(pivot: IVector2, angle: number): Vector2;
    skewed(pivot: IVector2, skewer: IVector2): Vector2;
    skew(pivot: IVector2, skewer: IVector2): void;
    static INVERSE(v1: IVector2): Vector2;
    inverse(): Vector2;
    static FLIPPED(v1: IVector2): Vector2;
    flipped(): Vector2;
    static MIDPOINT(arr: IVector2[]): Vector2;
    midPoint(other: IVector2 | IVector2[]): Vector2;
    floor(): Vector2;
    ceil(): Vector2;
    reflect(other: IVector2): Vector2;
    project(norm: IVector2): Vector2;
    slide(other: IVector2): Vector2;
    bounce(other: IVector2): Vector2;
    closestPoint(arr: IVector2[], exclusive?: boolean): IVector2;
    sortPointsByClosest(points: IVector2[]): IVector2[];
    toString(): string;
    asObject(): IVector2;
    asArray(): [number, number];
    toJSON(): Object;
    isGreaterThan(other: any): boolean;
    isLesserThan(other: any): boolean;
    static NEG(v1: IVector2): Vector2;
    neg(): Vector2;
    static quadraticBezier(points: IVector2[], t: number): IVector2;
    static quadraticBezierPoints(points: IVector2[], inc: number): IVector2[];
    static getSVGAngle(_u: IVector2, _v: IVector2): number;
}
